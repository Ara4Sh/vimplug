#!/bin/bash

# Simple script to update vim plugins

# Constants
BUNDLE_PATH="$HOME/.vim/bundle"

# Globals
exit_code=

# Downlaod and install plugins in $1.
#
# Arguments:
#    Comma separated plugins
# Returns:
#    None
install() {
	git clone $1
}

# Remove plugins in $1.
#
# Arguments:
#    Comma separated plugins
# Returns:
#    None
remove() {
	# Just make sure that we are in the right directory
	cd $BUNDLE_PATH
	stat $1 > /dev/null && rm -rf $1
}

# List plugins in $BUNDLE_PATH
#
# Arguments:
#    None
# Returns:
#    None
list() {
	printf "%-22s%-22s%-22s\n\n" "Plugin Name" "Last Updated" "Last Pull"
	for file in *; do
		if [[ -d $file ]] && is_git_repo $file; then
			cd $file
			last_updated=$(git show --date=iso | grep "Date" |
				sed -r 's/^Date:   //' | cut -d ' ' -f 1,2)
			last_pull=$(stat --printf=%y .git/FETCH_HEAD | cut -d . -f 1)
			printf "%-22s%-22s%-22s\n" "$file" "$last_updated" "$last_pull"
			cd ..
		fi
	done
}

# Update plugins in $1. If $1 is empty, update all.
#
# Arguments:
#    Comma separated plugins [OPTIONAL]
# Returns:
#    None
update() {
	local files
	local old_IFS
	local has_comma

	if [[ -z "$1" ]]; then
		files=$(ls)
	elif [[ "$1" =~ ^[,[:alnum:]]+$ ]]; then
		has_comma=true
		old_IFS=$IFS
		IFS=,
		files=$1
	else
		err "malformed argument: $1"
		exit 1
	fi

	for file in $files; do
		if [[ -d $file ]] && is_git_repo $file; then
			cd $file
			git pull origin master
			cd ..
		fi
	done
	if [[ "$has_comma" = true ]]; then
		IFS=$old_IFS
	fi
}

# Set global variable BUNDLE_PATH to $1 and cd to it.
#
# Arguments:
#     A path
# Returns:
#     None
set_bundle_path() {
	BUNDLE_PATH=$1
	cd $BUNDLE_PATH
}

print_help() {
	cat <<- "EOF"
	Usage: vimplug COMMAND [OPTION]...
	Manage VIM plugins.

	COMMANDs:
	    install         install plugins
	    list            list installed plugins
	    set-bundle-path set bundle path. Default $HOME/.vim/bundle
	    remove          remove plugins
	    update          update plugins
	    help            dispaly help for commands
	EOF
}

# Check if $1 has optional argument. If true, then pass an empty
# argument to the corresponding routine.
#
# Arguments:
#     A command-line option
# Returns:
#     None
handle_optional_arg() {
	case $1 in
	u) update ""
		;;
	*) err "option '-$1' requires an argument"
	   exit 1
		;;
	esac
}

# Check if $1 is a Git repository.
#
# Arguments:
#     A directory
# Returns:
#     Exit code of `git status`
is_git_repo() {
	cd $1
	git status &> /dev/null
	exit_code=$?
	cd ..
	return $exit_code
}

# Error reporting routine. Write to STDERR.
#
# Arguments:
#     A message
# Returns:
#     None
err() {
	echo "$1" 1>&2
}

main() {
	if [[ $# -eq 0 ]]; then
		err "missing command"
		exit 1
	fi

	if ! cd $BUNDLE_PATH 2> /dev/null; then
		err "$BUNDLE_PATH does not exist"
		exit 1
	fi

	case $1 in
	install)
		install "$@"
		;;
	list)
		list "$@"
		;;
	set-bundle-path)
		set_bundle_path "$@"
		;;
	remove)
		remove "$@"
		;;
	update)
		update "$@"
		;;
	help)
		print_help "$@"
		exit 0
		;;
	*)
		print_help "$@"
		exit 1
		;;
	esac

	# If we get here, all went smoothly
	exit 0
}

main "$@"
